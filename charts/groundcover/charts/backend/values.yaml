postgresql:
  jobs:
    createKeepUser:
      enabled: true
      annotations:
    createDbs:
      enabled: true
      annotations:
        helm.sh/hook-weight: "-1"
        helm.sh/hook: "pre-upgrade,pre-install"
        helm.sh/hook-delete-policy: "before-hook-creation"
  dbs: {}
  nameOverride: postgresql
  image:
    registry: public.ecr.aws/groundcovercom
    repository: bitnami/postgresql
    tag: 15.3.0-debian-11-r75
  tls:
    enabled: true
    autoGenerated: true
  serviceAccount:
    create: true
  commonLabels: '{{ include "groundcover.labels" . }}'
  volumePermissions:
    enabled: true
    image:
      registry: public.ecr.aws/groundcovercom
      repository: bitnami/os-shell
      tag: 11-debian-11-r91
  primary:
    containerSecurityContext:
      enabled: false
    podSecurityContext:
      enabled: false
    extraEnvVars:
      - name: INITDB_PGHOST
        value: localhost
      - name: INITDB_PGPORT
        value: '{{ splitList ":" (include "postgresql.base.url" .) | last }}'
      - name: POSTGRES_KEEP_USER
        valueFrom:
          secretKeyRef:
            optional: true
            name: keep-postgres
            key: username
      - name: POSTGRES_KEEP_DB
        valueFrom:
          secretKeyRef:
            optional: true
            name: keep-postgres
            key: database
      - name: POSTGRES_KEEP_PASSWORD
        valueFrom:
          secretKeyRef:
            optional: true
            name: keep-postgres
            key: password
      - name: POSTGRESQL_MAX_CONNECTIONS
        value: "400"
    podAnnotations: 
      groundcover.com/workflows: '{{ .Values.global.workflows.enabled }}'
    initContainers:
      - name: reset-user-scripts-initialized-flag
        image: '{{ include "postgresql.volumePermissions.image" . }}'
        command: 
            - /bin/sh
            - -ec
            - |
              initialized_flag="/bitnami/postgresql/.user_scripts_initialized"              
              if [ -f "${initialized_flag}" ]; then
                  rm "${initialized_flag}"
                  echo "${initialized_flag} removed."
              else
                  exit 0
              fi
        volumeMounts:
          - name: data
            mountPath: /bitnami/postgresql
    initdb:
      scripts: 
        01-sync-pg-password.sh: |
          #!/bin/bash
          
          info "Syncing pg_authid with secret"

          set -eu -o pipefail

          # Allow passwordless login for local client
          replace_in_file "$POSTGRESQL_PGHBA_FILE" "^\(local.*\) md5$" "\1 trust" false
          pg_ctl reload

          # sync password from k8s secret to pg_authid
          postgresql_alter_postgres_user "${POSTGRESQL_PASSWORD}"

          # Restore password auth constraints
          postgresql_restrict_pghba
          pg_ctl reload
        10-create-dbs.sh: |
          #!/bin/sh

          set -eu

          export PGHOST=${INITDB_PGHOST}
          export PGPORT=${INITDB_PGPORT}
          export PGPASSWORD=${POSTGRES_PASSWORD}

          create_database_if_not_exists() {
            local target_db="$1"

            echo "10-create-dbs.sh: CREATE DATABASE IF NOT EXISTS ${target_db}"
            echo "SELECT 'CREATE DATABASE ${target_db}' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '${target_db}')\gexec" | psql -U postgres
          }
          
          {{- range $db := (include "postgresql.create.dbs" . | split "\n") }}
          {{- if $db }}
          create_database_if_not_exists "{{ $db }}"
          {{- end }}
          {{- end }}
        11-create-keep-user.sh: |
          #!/bin/sh

            {{- if .Values.global.workflows.enabled }}
            set -eu

            export PGHOST=${INITDB_PGHOST}
            export PGPORT=${INITDB_PGPORT}
            export PGPASSWORD=${POSTGRES_PASSWORD}
            export PGKEEPUSER=${POSTGRES_KEEP_USER}
            export PGKEEPDB=${POSTGRES_KEEP_DB}
            export PGKEEPPASSWORD=${POSTGRES_KEEP_PASSWORD}

            create_database_if_not_exists() {
              echo "11-create-keep-user.sh: CREATE DATABASE IF NOT EXISTS '${PGKEEPDB}'"
              echo "SELECT 'CREATE DATABASE ${PGKEEPDB}' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '${PGKEEPDB}')\gexec" | psql -U postgres
            }

            create_user_with_password_if_not_exists() {
              echo "11-create-keep-user.sh: CREATE USER IF NOT EXISTS '${PGKEEPUSER}'"
              echo "SELECT 'CREATE USER ${PGKEEPUSER} WITH PASSWORD ''${PGKEEPPASSWORD}'';' WHERE NOT EXISTS (SELECT FROM pg_user WHERE usename = '${PGKEEPUSER}')\gexec" | psql -U postgres
            }

            grand_all_privileges_on_database_to_user() {
              echo "11-create-keep-user.sh: GRANT ALL PRIVILEGES ON DATABASE ${PGKEEPDB} TO ${PGKEEPUSER}"
              echo "GRANT ALL PRIVILEGES ON DATABASE ${PGKEEPDB} TO ${PGKEEPUSER}" | psql -U postgres
              echo "ALTER DATABASE ${PGKEEPDB} OWNER TO ${PGKEEPUSER}" | psql -U postgres
            }

            grand_all_privileges_on_schema_public_to_user() {
              echo "11-create-keep-user.sh: GRANT ALL PRIVILEGES ON SCHEMA public TO ${PGKEEPUSER}"
              echo "GRANT ALL PRIVILEGES ON SCHEMA public TO ${PGKEEPUSER}" | psql -U postgres -d ${PGKEEPDB}
            }

            override_user_password() {
              echo "11-create-keep-user.sh: OVERRIDE PASSWORD FOR USER ${PGKEEPUSER}"
              echo "ALTER USER ${PGKEEPUSER} WITH PASSWORD '${PGKEEPPASSWORD}';" | psql -U postgres
            }

            create_database_if_not_exists
            create_user_with_password_if_not_exists
            grand_all_privileges_on_database_to_user
            grand_all_privileges_on_schema_public_to_user
            override_user_password

            {{- end }}
          
keep:
  global:
    ingress:
      enabled: false
  namespace: ""
  deleteSecretJob:
    image:
      repository: public.ecr.aws/groundcovercom/bitnami/kubectl
  backend:
    provisionedProviders:
      victoriametrics:
        type: victoriametrics
        authentication:
          VMAlertURL: '{{ include "victoria-metrics.read.http.url" . }}'
      clickhouse:
        type: clickhouse
        authentication:
          username: '{{ include "clickhouse.username" . }}'
          password: '{{ include "clickhouse.password" . }}'
          host: '{{ include "clickhouse.fullname" . }}'
          port: '{{ .Values.global.clickhouse.containerPorts.tcp }}'
          database: '{{ include "clickhouse.database" . }}'
    enabled: true
    waitForDatabase:
      enabled: false
    image:
      repository: public.ecr.aws/groundcovercom/keep-api
      tag: "0.40.6.4"
    databaseConnectionStringFromSecret:
      enabled: true
      secretName: keep-postgres
      secretKey: connection_string
    podAnnotations:
      checksum/values: '{{ .Values | toJson | sha256sum }}'
      prometheus.io/port: "8080"
    env:
      - name: KEEP_USE_PROVIDER_CACHE
        value: "true"
      - name: KEEP_EXTRACT_IDENTITY
        value: "false"
      - name: KEEP_USE_LIMITER
        value: "true"
      - name: KEEP_LIMIT_CONCURRENCY
        value: "15/second"
      - name: KEEP_NO_AUTH_METRICS
        value: "true"
      - name: KEEP_STORE_WORKFLOW_LOGS
        value: "false"
      - name: KEEP_ENRICHMENT_DISABLED
        value: "false"
      - name: KEEP_MAINTENANCE_WINDOWS_ENABLED
        value: "false"
      - name: KEEP_CORRELATION_ENABLED
        value: "false"
      - name: KEEP_PROVIDER_DISTRIBUTION_ENABLED
        value: "false"
      - name: KEEP_AUDIT_EVENTS_ENABLED
        value: "false"
      - name: KEEP_CALCULATE_START_FIRING_TIME_ENABLED
        value: "false"
      - name: KEEP_DEBUG_TASKS
        value: "true"
      - name: KEEP_ALERT_FIELDS_ENABLED
        value: "false"
      - name: CONSUMER
        value: "false"
      - name: KEEP_DEDUPLICATION_DISTRIBUTION_ENABLED
        value: "false"
      - name: KEEP_CUSTOM_DEDUPLICATION_ENABLED
        value: "false"
      - name: POSTHOG_DISABLED
        value: "true"
      - name: PROMETHEUS_MULTIPROC_DIR
        value: "/tmp/prometheus"
      - name: KEEP_PROVIDERS
        configMapKeyRef:
          key: provisionedProviders.json
          name: keep-config
      - name: CLICKHOUSE_PASS
        secretKeyRef:
          secretKey: '{{ include "clickhouse.secretKey" . }}'
          secretName: '{{ include "clickhouse.secretName" . }}'
      - name: PUSHER_DISABLED
        value: "true"
      - name: KEEP_IMPERSONATION_ENABLED
        value: "true"
      - name: KEEP_IMPERSONATION_AUTO_PROVISION
        value: "true"
      - name: SERVICE_NAME
        value: '{{ include "keep.backend.fullname" . }}'
      - name: OTLP_ENDPOINT
        value: '{{ include "telemetry.traces.otlpUrl" . }}'
      - name: OTLP_SPAN_EXPORTER
        value: 'http'
      - name: TRACING_HEADERS_APIKEY 
        secretKeyRef:
          secretName: '{{ template "groundcover.apikeySecretName" . }}'
          secretKey: '{{ template "groundcover.apikeySecretKey" . }}'
      - name: OTEL_EXPORTER_OTLP_HEADERS
        value: "apikey=$(TRACING_HEADERS_APIKEY)"
      - name: SECRET_MANAGER_TYPE
        value: K8S
      - name: KEEP_DEFAULT_API_KEYS
        secretKeyRef:
          secretName: keep-credentials
          secretKey: api-keys
      - name: AUTH_TYPE
        value: SINGLE_TENANT
      - name: KEEP_DEFAULT_USERNAME 
        secretKeyRef:
          secretName: keep-credentials
          secretKey: username
      - name: KEEP_DEFAULT_PASSWORD
        secretKeyRef:
          secretName: keep-credentials
          secretKey: password
      - name: DATABASE_POOL_SIZE
        value: 200
    extraInitContainers:
      - name: wait-for-db
        image: '{{ include "postgresql.image" . }}'
        env:
          - name: POSTGRES_USERNAME
            valueFrom:
                secretKeyRef:
                  name: keep-postgres
                  key: username
          - name: POSTGRES_DB_NAME
            valueFrom:
                secretKeyRef:
                  name: keep-postgres
                  key: database
        command:
          - /bin/sh
          - -c
        args:
          - |
            pg_isready \
              -U "${POSTGRES_USERNAME}" \
              -d "dbname=${POSTGRES_DB_NAME}" \
              -h {{ splitList ":" (include "postgresql.base.url" .) | first }} \
              -p {{ splitList ":" (include "postgresql.base.url" .) | last }}
  frontend:
    enabled: false
  database:
    enabled: false
  websocket:
    enabled: false

victoria-metrics-distributed:
  nameOverride: "victoriametrics"
  extra:
    vmagent:
      enabled: false
  enableMultitenancy: false
  victoria-metrics-k8s-stack:
    enabled: false
    grafana:
      enabled: false
  availabilityZones: []
  pvcAnnotationsJob:
    image: "{{ .Values.global.origin.registry }}/bitnami/kubectl:latest"
    vmstorage:
      enabled: false
      annotations:
  common:
    vmauth:
      spec:
        replicaCount: 2
        resources:
          limits:
            cpu: 500m
          requests:
            cpu: 100m
        extraArgs:
          httpAuthHeader: "rnd-header-efe9c0e5-auth-disabled"
        podMetadata:
          annotations:
            prometheus.io/port: "8427"
            prometheus.io/scrape: "true"
          labels:
            app.groundcover.com/pipeline: metrics
            app.kubernetes.io/part-of: groundcover
  zoneTpl:
    common:
      spec:
        topologySpreadConstraints: []
    vmagent:
      spec:
        containers:
        - env:
          - name: POD_NAME
            valueFrom:
              fieldRef:
                fieldPath: metadata.name
          name: vmagent
        extraArgs:
          remoteWrite.maxDiskUsagePerURL: 50GB
        podMetadata:
          annotations:
            prometheus.io/port: "8429"
            prometheus.io/scrape: "true"
          labels:
            app.groundcover.com/pipeline: metrics
            app.kubernetes.io/part-of: "groundcover"
        statefulMode: false
        streamAggrConfig:
          configmap:
            key: aggregation_config.yaml
            name: victoria-metrics-aggregation-config
        replicaCount: 1
        resources:
          limits:
            cpu: 15
            memory: 6Gi
          requests:
            cpu: 1
            memory: 6Gi
    vmcluster:
      enabled: true
      spec:
        replicationFactor: 2
        retentionPeriod: 30d
        vminsert:
          extraArgs:
            maxConcurrentInserts: "1000"
            maxLabelsPerTimeseries: "50"
          podMetadata:
            annotations:
              prometheus.io/port: "8480"
              prometheus.io/scrape: "true"
            labels:
              app.groundcover.com/pipeline: metrics
              app.kubernetes.io/part-of: groundcover
          replicaCount: 2
          resources:
            limits:
              cpu: 10
              memory: 3Gi
            requests:
              cpu: 500m
              memory: 2Gi
        vmselect:
          extraArgs:
            search.maxQueryLen: "100000"
            search.maxSeries: "30000"
            search.maxUniqueTimeseries: "2000000"
          podMetadata:
            annotations:
              prometheus.io/port: "8481"
              prometheus.io/scrape: "true"
            labels:
              app.groundcover.com/pipeline: metrics
              app.kubernetes.io/part-of: groundcover
          replicaCount: 2
          resources:
            limits:
              cpu: 10
              memory: 3Gi
            requests:
              cpu: 400m
              memory: 1Gi
          storage:
            volumeClaimTemplate:
              spec:
                resources:
                  requests:
                    storage: 10Gi
        vmstorage:
          extraArgs:
            search.maxConcurrentRequests: "8"
            search.maxTagKeys: "200000"
            search.maxTagValues: "500000"
          podMetadata:
            annotations:
              prometheus.io/port: "8482"
              prometheus.io/scrape: "true"
            labels:
              app.groundcover.com/pipeline: metrics
              app.kubernetes.io/part-of: groundcover
          storageDataPath: /vm-data                    
          replicaCount: 3
          resources:
            limits:
              cpu: 10
              memory: 5Gi
            requests:
              cpu: 600m
              memory: 5Gi
          storage:
            volumeClaimTemplate:
              spec:
                resources:
                  requests:
                    storage: 10Gi
  read:
    global:
      vmauth:
        name: "read-global-groundcover"             
  write:
    global:
      vmauth:
        name: "write-global-groundcover"

# Custom temporal configuration (for our templates)
temporalConfig:
  enabled: false
  adminTools:
    image:
      repository: us-docker.pkg.dev/groundcovercom/repo/temporalio/admin-tools
      tag: "1.22.6"
      pullPolicy: IfNotPresent
  postgres:
    host: "NONE"  # Set to "NONE" to read from secret, or specify host directly
    port: 5432
    database: temporal
    username: postgres
    secret:
      name: "managed-postgres-credentials"  # Default for production
      passwordKey: "password"  # Default key in production secrets
      hostKey: "host"  # Key in secret containing the host
      portKey: "port"  # Key in secret containing the port
      usernameKey: "username"  # Key in secret containing the username
    tls:
      enabled: true


# Temporal subchart values
# These are passed directly to the temporal subchart
temporal:
  # Admin tools for schema management are handled by our custom job
  admintools:
    enabled: false

  # Server configuration
  server:
    replicaCount: 2
    image:
      repository: us-docker.pkg.dev/groundcovercom/repo/temporalio/server
      tag: 1.22.4
    config:
      persistence:
        defaultStore: default
        additionalStores: {}
        # Database configuration will be injected based on temporalConfig settings
        default:
          driver: sql
          sql:
            driver: postgres12
            host: "{{ .Env.TEMPORAL_STORE_HOST }}"
            port: "{{ .Env.TEMPORAL_STORE_PORT }}"
            database: "{{ .Env.TEMPORAL_STORE_DATABASE }}"
            user: "{{ .Env.TEMPORAL_STORE_USER }}"
            maxConns: 20
            maxIdleConns: 20
            maxConnLifetime: 1h
            tls:
              enabled: false
              enableHostVerification: false
        visibility:
          driver: sql
          sql:
            driver: postgres12
            host: "{{ .Env.TEMPORAL_VISIBILITY_HOST }}"
            port: "{{ .Env.TEMPORAL_VISIBILITY_PORT }}"
            database: "{{ .Env.TEMPORAL_VISIBILITY_DATABASE }}"
            user: "{{ .Env.TEMPORAL_VISIBILITY_USER }}"
            maxConns: 20
            maxIdleConns: 20
            maxConnLifetime: 1h
            tls:
              enabled: false
              enableHostVerification: false
  
  frontend:
    replicaCount: 2
    additionalEnv: []  # Will be overridden by parent chart or deployment
    podDisruptionBudget:
      maxUnavailable: 1

  history:
    replicaCount: 2
    additionalEnv: []  # Will be overridden by parent chart or deployment
    podDisruptionBudget:
      maxUnavailable: 1

  matching:
    replicaCount: 2
    additionalEnv: []  # Will be overridden by parent chart or deployment
    podDisruptionBudget:
      maxUnavailable: 1

  worker:
    replicaCount: 2
    additionalEnv: []  # Will be overridden by parent chart or deployment
    podDisruptionBudget:
      maxUnavailable: 1
  
  web:
    enabled: true
    replicaCount: 1
    image:
      repository: us-docker.pkg.dev/groundcovercom/repo/temporalio/ui
      tag: 2.16.2

  admintools:
    enabled: true
    image:
      repository: us-docker.pkg.dev/groundcovercom/repo/temporalio/admin-tools
      tag: 1.22.4

  # Disable schema management - handled by our job
  schema:
    setup:
      enabled: false
    update:
      enabled: false
    createDatabase:
      enabled: false

  # Disable all data stores we don't use
  cassandra:
    enabled: false
  mysql:
    enabled: false
  postgresql:
    enabled: false
  elasticsearch:
    enabled: false
  prometheus:
    enabled: false
  grafana:
    enabled: false


# CHIP (ClickHouse Ingestion Pipeline) Configuration
chip:
  enabled: false

  replicaCount: 1

  image:
    registry: public.ecr.aws/groundcovercom
    repository: chip
    tag: "0.0.10"
    pullPolicy: Always

  serviceAccount:
    # Name will be set by terraform when enabled
    name: ""
    annotations: {}

  # Tables to process - worker will automatically manage workflows for these tables
  tables:
    - logs_v6
    - traces_v2

  # S3 storage configuration - will be populated by terraform
  storage:
    s3:
      bucket: ""
      region: ""

  # Processing configuration
  processing:
    optimalFileSizeRows: "7900000"
    targetFileSizeMB: "256"
    workloadBuckets: "16"
    hashFunction: "xxh3"

  # Temporal configuration
  temporal:
    # Temporal host - defaults to <release-name>-temporal-frontend:7233
    host: ""
    taskQueue: "clickhouse-log-processing"
    namespace: "default"

  # Log level
  logLevel: "INFO"

  # Node selector and tolerations
  nodeSelector: {}
  tolerations: []

  # Resource limits
  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "2Gi"
      cpu: "2000m"
