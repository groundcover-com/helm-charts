{{- if .Values.global.temporal.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Release.Name }}-temporal-schema-setup
  namespace: {{ .Release.Namespace }}
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation
  labels:
    app.kubernetes.io/name: temporal
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/component: schema-setup
    {{- include "groundcover.labels" . | nindent 4 }}
spec:
  template:
    metadata:
      labels:
        app.kubernetes.io/name: temporal
        app.kubernetes.io/instance: {{ .Release.Name }}
        app.kubernetes.io/component: schema-setup
    spec:
      restartPolicy: OnFailure
      {{- with .Values.global.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with (include "temporal.nodeSelector" .) }}
      nodeSelector:
        {{- . | nindent 8 }}
      {{- end }}
      {{- with (include "temporal.tolerations" .) }}
      tolerations:
        {{- . | nindent 8 }}
      {{- end }}
      containers:
      - name: schema-setup
        image: "{{ .Values.temporalConfig.adminTools.image.repository }}:{{ .Values.temporalConfig.adminTools.image.tag | default "1.22.6" }}"
        imagePullPolicy: {{ .Values.temporalConfig.adminTools.image.pullPolicy | default "IfNotPresent" }}
        env:
        - name: SQL_PLUGIN
          value: "postgres"
        - name: SQL_HOST
          {{- if eq .Values.temporalConfig.postgres.host "NONE" }}
          valueFrom:
            secretKeyRef:
              name: {{ .Values.temporalConfig.postgres.secret.name | quote }}
              key: {{ .Values.temporalConfig.postgres.secret.hostKey | quote }}
          {{- else }}
          value: {{ .Values.temporalConfig.postgres.host | quote }}
          {{- end }}
        - name: SQL_PORT
          value: {{ .Values.temporalConfig.postgres.port | quote }}
        - name: SQL_USER
          {{- if eq .Values.temporalConfig.postgres.username "NONE" }}
          valueFrom:
            secretKeyRef:
              name: {{ .Values.temporalConfig.postgres.secret.name | quote }}
              key: {{ .Values.temporalConfig.postgres.secret.usernameKey | quote }}
          {{- else }}
          value: {{ .Values.temporalConfig.postgres.username | quote }}
          {{- end }}
        - name: SQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ .Values.temporalConfig.postgres.secret.name | quote }}
              key: {{ .Values.temporalConfig.postgres.secret.passwordKey | quote }}
        - name: TEMPORAL_DB
          value: {{ .Values.temporalConfig.postgres.database | quote }}
        - name: VISIBILITY_DB
          value: {{ printf "%s_visibility" .Values.temporalConfig.postgres.database | quote }}
        volumeMounts:
        - name: temporal-schema-volume
          mountPath: /schema/temporal
        - name: temporal-visibility-schema-volume
          mountPath: /schema/visibility
        command: ["/bin/bash", "-c"]
        args:
        - |
          set -ex

          echo "Creating Temporal databases..."

          # First, create the databases using psql connected to the default postgres database
          export PGPASSWORD=$SQL_PASSWORD

          echo "Creating database $TEMPORAL_DB if it doesn't exist..."
          psql -h $SQL_HOST -p $SQL_PORT -U $SQL_USER -d postgres -tc "SELECT 1 FROM pg_database WHERE datname = '$TEMPORAL_DB'" | grep -q 1 || \
          psql -h $SQL_HOST -p $SQL_PORT -U $SQL_USER -d postgres -c "CREATE DATABASE \"$TEMPORAL_DB\""

          echo "Creating database $VISIBILITY_DB if it doesn't exist..."
          psql -h $SQL_HOST -p $SQL_PORT -U $SQL_USER -d postgres -tc "SELECT 1 FROM pg_database WHERE datname = '$VISIBILITY_DB'" | grep -q 1 || \
          psql -h $SQL_HOST -p $SQL_PORT -U $SQL_USER -d postgres -c "CREATE DATABASE \"$VISIBILITY_DB\""

          echo "Setting up Temporal schema..."

          # Setup temporal schema
          temporal-sql-tool \
            --tls {{ if .Values.temporalConfig.postgres.tls.enabled }}--tls-disable-host-verification{{ end }} \
            --plugin $SQL_PLUGIN \
            --ep $SQL_HOST \
            --port $SQL_PORT \
            --user $SQL_USER \
            --password $SQL_PASSWORD \
            --database $TEMPORAL_DB \
            setup-schema -v 0.0

          echo "Preparing schema files for temporal database..."
          TMP_SCHEMA_DIR_TEMPORAL="/tmp/schema_files_temporal"
          mkdir -p "$TMP_SCHEMA_DIR_TEMPORAL"

          # Copy and organize files from ConfigMap mount to versioned subdirectories
          for f_path in /schema/temporal/*; do
            if [ -f "$f_path" ]; then
              raw_fname=${f_path##*/}
              case "$raw_fname" in
                v[0-9]*_[0-9]*_*_sql)
                  # Extract version from filename like v1_16_fix_data_encoding_column_sql
                  version=$(echo "$raw_fname" | sed -E 's/v([0-9]+)_([0-9]+)_.*/\1.\2/')
                  sql_file_name=$(echo "$raw_fname" | sed -E 's/v[0-9]+_[0-9]+_(.*)_sql/\1.sql/')

                  target_version_dir="$TMP_SCHEMA_DIR_TEMPORAL/v$version"
                  mkdir -p "$target_version_dir"
                  cp -v "$f_path" "$target_version_dir/$sql_file_name"
                  ;;
              esac
            fi
          done

          # Generate manifest.json for each version
          for version_dir in $TMP_SCHEMA_DIR_TEMPORAL/v*; do
            if [ -d "$version_dir" ]; then
              version_name=${version_dir##*/}
              version_number=${version_name#v}

              cat > "$version_dir/manifest.json" <<MANIFEST
          {
            "CurrVersion": "$version_number",
            "MinCompatibleVersion": "1.0",
            "Description": "Schema update for version $version_number",
            "SchemaUpdateCqlFiles": [
          MANIFEST

              first_file=true
              for sql_file in "$version_dir"/*.sql; do
                if [ -f "$sql_file" ]; then
                  sql_filename=${sql_file##*/}
                  if [ "$first_file" = true ]; then
                    echo "    \"$sql_filename\"" >> "$version_dir/manifest.json"
                    first_file=false
                  else
                    echo "    ,\"$sql_filename\"" >> "$version_dir/manifest.json"
                  fi
                fi
              done

              cat >> "$version_dir/manifest.json" <<MANIFEST
            ]
          }
          MANIFEST
            fi
          done

          temporal-sql-tool \
            --tls {{ if .Values.temporalConfig.postgres.tls.enabled }}--tls-disable-host-verification{{ end }} \
            --plugin $SQL_PLUGIN \
            --ep $SQL_HOST \
            --port $SQL_PORT \
            --user $SQL_USER \
            --password $SQL_PASSWORD \
            --database $TEMPORAL_DB \
            update-schema -d $TMP_SCHEMA_DIR_TEMPORAL || echo "Schema update completed or already up to date"

          echo "Setting up Visibility schema..."

          # Setup visibility schema
          temporal-sql-tool \
            --tls {{ if .Values.temporalConfig.postgres.tls.enabled }}--tls-disable-host-verification{{ end }} \
            --plugin $SQL_PLUGIN \
            --ep $SQL_HOST \
            --port $SQL_PORT \
            --user $SQL_USER \
            --password $SQL_PASSWORD \
            --database $VISIBILITY_DB \
            setup-schema -v 0.0

          echo "Preparing schema files for visibility database..."
          TMP_SCHEMA_DIR_VISIBILITY="/tmp/schema_files_visibility"
          mkdir -p "$TMP_SCHEMA_DIR_VISIBILITY"

          # Copy and organize files from ConfigMap mount to versioned subdirectories
          for f_path in /schema/visibility/*; do
            if [ -f "$f_path" ]; then
              raw_fname=${f_path##*/}
              case "$raw_fname" in
                v[0-9]*_[0-9]*_*_sql)
                  # Extract version from filename like v1_0_schema_sql
                  version=$(echo "$raw_fname" | sed -E 's/v([0-9]+)_([0-9]+)_.*/\1.\2/')
                  sql_file_name=$(echo "$raw_fname" | sed -E 's/v[0-9]+_[0-9]+_(.*)_sql/\1.sql/')

                  target_version_dir="$TMP_SCHEMA_DIR_VISIBILITY/v$version"
                  mkdir -p "$target_version_dir"
                  cp -v "$f_path" "$target_version_dir/$sql_file_name"
                  ;;
              esac
            fi
          done

          # Generate manifest.json for each version
          for version_dir in $TMP_SCHEMA_DIR_VISIBILITY/v*; do
            if [ -d "$version_dir" ]; then
              version_name=${version_dir##*/}
              version_number=${version_name#v}

              cat > "$version_dir/manifest.json" <<MANIFEST
          {
            "CurrVersion": "$version_number",
            "MinCompatibleVersion": "1.0",
            "Description": "Visibility schema update for version $version_number",
            "SchemaUpdateCqlFiles": [
          MANIFEST

              first_file=true
              for sql_file in "$version_dir"/*.sql; do
                if [ -f "$sql_file" ]; then
                  sql_filename=${sql_file##*/}
                  if [ "$first_file" = true ]; then
                    echo "    \"$sql_filename\"" >> "$version_dir/manifest.json"
                    first_file=false
                  else
                    echo "    ,\"$sql_filename\"" >> "$version_dir/manifest.json"
                  fi
                fi
              done

              cat >> "$version_dir/manifest.json" <<MANIFEST
            ]
          }
          MANIFEST
            fi
          done

          temporal-sql-tool \
            --tls {{ if .Values.temporalConfig.postgres.tls.enabled }}--tls-disable-host-verification{{ end }} \
            --plugin $SQL_PLUGIN \
            --ep $SQL_HOST \
            --port $SQL_PORT \
            --user $SQL_USER \
            --password $SQL_PASSWORD \
            --database $VISIBILITY_DB \
            update-schema -d $TMP_SCHEMA_DIR_VISIBILITY || echo "Visibility schema update completed or already up to date"

          echo "Temporal schema setup completed successfully!"
      volumes:
      - name: temporal-schema-volume
        configMap:
          name: temporal-schema-files
      - name: temporal-visibility-schema-volume
        configMap:
          name: temporal-visibility-schema-files
{{- end }}